fragment recognizer E1 {
limit(REAL_TIME, 15s);
	{ notice("FOO"); }
	task("PARSE_REQUEST")
		limit(CPU_TIME, {0s, 2s});
	task("REVERSE_DNS_LOOKUP")
		limit(REAL_TIME, {10s+});
	notice("CACHE_MISS");
	notice(m/^FOO/);
	task("LINK") {
		task("SP_TREE");
	}
	xor {
		branch: notice("THIS");
		branch: notice("THAT");
	}
}

invalidator X1 {
	thread Client(*, 1) {
		task("outer") {
			task("inner");   // "inner" cannot be nested alone in "outer"
		}
	}
}

fragment invalidator X2 {
	task(*) limit(REAL_TIME, {1s+});  // no tasks over one second
}

fragment recognizer E2 { }

fragment recognizer E3 {
  xor {
    branch: call(E1);
    branch: call(E2);
  }
}

recognizer E5 {
	thread Mumble(*, {1,100}) {
		any();
	}
}

validator E4 {
	thread Client(*, 1) {
		send(Client,Mumble);
		task("foo");
		recv(Client);
	}
	thread Mumble(*, {2,4}) {
	}
}

validator DHT_recursive_shortcut {
	thread Client(*, 1) {
		limit(SIZE, 10kb);
		task(m/^DHT/);
		repeat between 1 and 5 {
			send(Client)
				limit(SIZE, 1kb)
				limit(LATENCY, 0.5s);
			task("DHT");
		}
		recv(Client);
		task("DHT");
	}
}

validator DHT_iterative {
	thread Client(*, 1) {
		task("DHT");
		repeat between 1 and 5 {
			send(Client);
			task("DHT");
			recv(Client);
			task("DHT");
		}
	}
}

validator DHT_recursive {
	thread Client(*, 1) {
		task("DHT");
		send(Client);
		@PATH = repeat between 1 and 5 {
			task("DHT");
			recv(Client);
		}
		task("DHT");
		recv(Client);
		task("DHT");
	}
}

validator DHT_Coral {
	thread Client(*, 1) {
		task("DHT");
		send(Client);
		task("DHT");
		recv(Client);
		repeat 2 {
			send(Client);
			task("DHT");
			send(Client);
			task("DHT");
			send(Client);
			task("DHT");
		}
		recv(Client);
		task("DHT");
		recv(Client);
		task("DHT")
		limit(CPU_TIME, 10s);
	}
}

fragment recognizer Timer {
  notice("timer");
}

assert( instances(E1) in { 1, 5 } );
assert( instances(E1) < 5 );
assert( instances(E1) > 1 );
assert( instances(E1) >= 4 );
assert( instances(E1) <= 5 );
assert( instances(E1) != 0 );
assert( 5. < 2.**3. );
assert( exp(2.) < ln(10000.) );
assert( log(1000000.) == 6. );
//during(any 0) assert( unique(E1) == unique(E2) );
//during(any 5) assert( instances(E1) > 0 -> instances(E2) == 0 );
//during(1, 10) assert( unique($HERE) == 1 );
assert( average(CPU_TIME, E1) < 5s );
assert( stddev(INVOL_CS, E1) < 5ms );
//assert( max(REAL_TIME, "DHT") in { 0, 10 } );
//assert( min(REAL_TIME, "DHT") in { 0, 10 } );
